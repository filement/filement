#if !defined(OS_WINDOWS)

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/file.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include "types.h"
#include "format.h"
#include "log.h"
#include "io.h"
#include "startup.h"

#define PATH_LENGTH_MAX 4096
#define NAME_LENGTH_MAX 255

#define STARTUP_FILENAME ".filement.startup"
#define STARTUP_CONTENT "#!/bin/sh\n# Generated by Filement for startup initialization.\n\n"
#define STARTUP_CALL "\n" \
	"# Generated by Filement for startup initialization.\n" \
	". ~/" STARTUP_FILENAME "\n"

#define STRING(s) (s), sizeof(s) - 1

static int startup_file = -1;

// Add call from a given file to the startup file.
static int startup_call(const char *filepath)
{
	int file = open(filepath, O_WRONLY | O_APPEND, 0740);
	if (file < 0) return errno_error(errno);

	// Make sure no other process is using the file at the moment.
	int status = 0;
	if (flock(file, LOCK_EX | LOCK_NB) < 0) status = errno_error(errno);
	else if (!writeall(file, STARTUP_CALL, sizeof(STARTUP_CALL) - 1)) status = errno_error(errno);

	close(file);
	return status;
}

bool startup_init(void)
{
#if defined(OS_IOS)
	return true;
#endif

	// WARNING: each filename must be no longer than NAME_LENGTH_MAX

	char *home = getenv("HOME");
	size_t home_length = strlen(home);
	if (!home || (home_length >= (PATH_LENGTH_MAX - NAME_LENGTH_MAX))) return false;

	char filepath[PATH_LENGTH_MAX];
	char *filename = format_bytes(filepath, home, home_length);
	*filename++ = '/';

	// Open the filement startup script. Create it if it doesn't exist.
	*format_bytes(filename, STRING(STARTUP_FILENAME)) = 0;
	startup_file = open(filepath, O_RDWR);
	if (startup_file < 0)
	{
		if (errno == ENOENT)
		{
			// Create filement startup file.
			startup_file = open(filepath, O_CREAT | O_RDWR, 0740);
			if (startup_file < 0) goto error;
			if (!writeall(startup_file, STARTUP_CONTENT, sizeof(STARTUP_CONTENT) - 1))
			{
				unlink(filepath);
				goto error;
			}

			// Add call to the filement startup script in each file executed at login shell startup.

			int status;

			*format_bytes(filename, STRING(".bash_profile")) = 0;
			status = startup_call(filepath);
			if (status && (status != ERROR_MISSING)) goto error;

			*format_bytes(filename, STRING(".bash_login")) = 0;
			status = startup_call(filepath);
			if (status && (status != ERROR_MISSING)) goto error;

			*format_bytes(filename, STRING(".profile")) = 0;
			status = startup_call(filepath);
			if (status && (status != ERROR_MISSING)) goto error;
		}
		else goto error;
	}

	// Keep shared lock on the startup file so that exclusive locks on it will fail.
	// Try to make exclusive lock on the startup file to make sure this is the only device instance started.
	if (flock(startup_file, LOCK_EX | LOCK_NB) || flock(startup_file, LOCK_SH | LOCK_NB)) goto error;

	return true;

error:
	if (startup_file >= 0) startup_term();
	return false;
}

void startup_term(void)
{
	close(startup_file);
}

bool startup_add(const struct string *path)
{
	struct stat info;
	if (fstat(startup_file, &info) < 0) return false;

	struct string terminator = string("\n");
	struct string *pattern = 0;
	size_t *table;
	bool resize = true;
	bool success = false;

	struct string buffer = {.length = (size_t)info.st_size}; // WARNING: this cast limits the size of the startup file
	size_t size_max = buffer.length + path->length + 1;
	if (ftruncate(startup_file, size_max) < 0) goto finally;
	buffer.data = mmap(0, size_max, PROT_READ | PROT_WRITE, MAP_SHARED, startup_file, 0);
	if (buffer.data == MAP_FAILED) goto finally;

	pattern = string_concat(&terminator, path, &terminator);
	if (!pattern) goto finally;
	table = kmp_table(pattern);
	if (!table) goto finally;

	// Add the application if it's not added yet.
	success = (kmp_search(pattern, table, &buffer) >= 0);
	free(table);
	if (!success)
	{
		memcpy(buffer.data + buffer.length, pattern->data + 1, pattern->length - 1);
		resize = false;
	}
	success = true;

finally:

	free(pattern);
	if (buffer.data) munmap(buffer.data, size_max);
	if (resize) ftruncate(startup_file, buffer.length);

	return success;
}

bool startup_remove(const struct string *path)
{
	struct stat info;
	if (fstat(startup_file, &info) < 0) return false;

	struct string buffer = {.length = (size_t)info.st_size}; // WARNING: this cast limits the size of the startup file
	buffer.data = mmap(0, buffer.length, PROT_READ | PROT_WRITE, MAP_SHARED, startup_file, 0);
	if (buffer.data == MAP_FAILED) return false;

	struct string terminator = string("\n");
	struct string *pattern = 0;
	size_t *table;
	ssize_t index;
	bool resize = false;
	bool success = false;

	pattern = string_concat(&terminator, path, &terminator);
	if (!pattern) goto finally;
	table = kmp_table(pattern);
	if (!table) goto finally;

	// Remove the application if it's added to the startup items.
	index = kmp_search(pattern, table, &buffer);
	free(table);
	if (index >= 0)
	{
		for(index += pattern->length; index < buffer.length; ++index)
			buffer.data[index - pattern->length + 1] = buffer.data[index];
		resize = true;
	}

	success = true;

finally:

	free(pattern);
	munmap(buffer.data, buffer.length);
	if (resize) ftruncate(startup_file, buffer.length - pattern->length + 1);

	return success;
}

#else /* OS_WINDOWS */

#include <sys/stat.h>
#define WINVER 0x0501
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include "mingw.h"

#include "types.h"

bool startup_init(void) {return true;}
bool startup_add(const struct string *path) {return true;}
bool startup_remove(const struct string *path) {return true;}
void startup_term(void) {}

#endif
