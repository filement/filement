#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include <libmemcached/memcached.h>		// libmemcached
#include <mysql/mysql.h>				// libmysql

#include "types.h"
#include "log.h"
#include "format.h"
#include "protocol.h"
#include "filement.h"
#include "uuid.h"
#include "db.h"
#include "authorize.h"

#if !TEST
# define MEMCACHE_HOST "172.16.0.63"
# define MEMCACHE_PORT 11211
#else
# define MEMCACHE_HOST "217.18.246.187"
# define MEMCACHE_PORT 11211
#endif

static const struct credential authorized[] = {@{AUTHORIZED}};
#define authorized_count (sizeof(authorized) / sizeof(*authorized))

const struct credential *authorize_rights(const struct sockaddr_storage *restrict storage)
{
	// Generate address representation that is uniform for all address families.
	uint8_t address[ADDRESS_SIZE];
	switch (storage->ss_family)
	{
		uint8_t *position;

	case AF_INET:
		#define PREFIX_IPv4_MAPPED "@{PREFIX_IPv4_MAPPED}"
		position = format_bytes(address, PREFIX_IPv4_MAPPED, sizeof(PREFIX_IPv4_MAPPED) - 1);
		#undef PREFIX_IPv4_MAPPED
		format_bytes(position, (unsigned char *)&((struct sockaddr_in *)storage)->sin_addr, sizeof(in_addr_t)); // we can do this because in_addr_t is stored in big endian
		//
        break;

    case AF_INET6:
		format_bytes(address, ((struct sockaddr_in6 *)storage)->sin6_addr.s6_addr, ADDRESS_SIZE);
        break;

	default:
		return 0; // invalid address
	}

	// Binary search for address in the array of authorized addresses.
	size_t left = 0, right = authorized_count, search;
	int diff;
	while (left < right)
	{
		// look for address in [left, right)
		search = left + (right - left) / 2;
		diff = memcmp(address, authorized[search].address, ADDRESS_SIZE);
		if (diff > 0) left = search + 1;
		else if (diff < 0) right = search;
		else return authorized + search;
	}

	warning(logs("Unauthorized event received."));
	return 0; // no rights for this address
}

int32_t authorize_id(const char *restrict buffer, char key[restrict 16 + 1])
{
	memcached_st *memc = memcached_create(0);
	if (!memc) return -1; // TODO error
	memcached_return_t rc;

	//printf("%s\n", memcached_strerror(memc, rc));

	// TODO: memory leaks on error

	// Initialize server list
	memcached_server_st *servers = memcached_server_list_append(NULL, MEMCACHE_HOST, MEMCACHE_PORT, &rc);
	if (!servers) return -1; // TODO: error
	memcached_server_push(memc, servers);
	memcached_server_free(servers);

	#define ID_PREFIX "fstoken_"
	size_t key_length = sizeof(ID_PREFIX) - 1 + 32;
	char key_data[sizeof(ID_PREFIX) - 1 + 32 + 1];
	memcpy(key_data, ID_PREFIX, sizeof(ID_PREFIX) - 1);
	memcpy(key_data + sizeof(ID_PREFIX) - 1, buffer, 32);
	key_data[key_length] = 0;
	#undef ID_PREFIX

	char *return_data;
	size_t return_length;

	uint32_t flags;
	memcached_return_t error;
	return_data = memcached_get(memc, key_data, key_length, &return_length, &flags, &error);
	if (!return_data) return -1; // TODO: error
	memcached_delete(memc, key_data, key_length, 0); // TODO error check
	memcached_free(memc);

	char *end;
	uint32_t client_id = (uint32_t)strtol(return_data, &end, 10);
	if (key)
	{
		if (((end + 1 + (16 * 2) - return_data) > return_length) || (*end != ' ')) return -1; // TODO error
		hex2bin(key, end + 1, (16 * 2));
	}

	free(return_data);

	if (client_id < CLIENTS_LIMIT) return client_id;
}

// TODO: make this use db (instead of a new connection)
int32_t authorize_email(struct string *restrict email)
{
	// TODO: REMOVE
	MYSQL *mysql = malloc(sizeof(MYSQL));
	mysql_init(mysql);
	mysql_real_connect(mysql, OLD_HOSTNAME, OLD_USERNAME, OLD_PASSWORD, OLD_SCHEMA, OLD_PORT, 0, 0);

	// Transform email domain to lower case.
	size_t index = email->length;
	while (index-- && (email->data[index] != '@'))
		email->data[index] = tolower(email->data[index]);

	unsigned long length = (unsigned long)email->length;
	int client_id;

	MYSQL_STMT *stmt = mysql_stmt_init(mysql);
	if (!stmt)
	{
		mysql_close(mysql);
		free(mysql);
		return -1;
	}

	struct string query = string("select user_id from td_users where mail=?");
	if (mysql_stmt_prepare(stmt, query.data, query.length)) goto error;

	MYSQL_BIND value = {
		.buffer_type = MYSQL_TYPE_STRING,
		.buffer = email->data,
		.buffer_length = length + 1,
		.length = &length
	};
	if (mysql_stmt_bind_param(stmt, &value)) goto error;

	MYSQL_BIND result = {
		.buffer_type = MYSQL_TYPE_LONG,
		.buffer = &client_id,
		.buffer_length = (unsigned long)sizeof(client_id)
	};
	if (mysql_stmt_bind_result(stmt, &result) != 0) goto error;

	if (mysql_stmt_execute(stmt) || mysql_stmt_store_result(stmt) || (mysql_stmt_fetch(stmt) == MYSQL_NO_DATA))
		goto error;

	mysql_stmt_close(stmt);

	// TODO: REMOVE
	mysql_close(mysql);
	free(mysql);

	if (client_id >= CLIENTS_LIMIT) return -1;
	return (int32_t)client_id;

error:
	mysql_stmt_close(stmt);

	// TODO: REMOVE
	mysql_close(mysql);
	free(mysql);

	return -1;
}

bool authorize_secret(const char uuid[UUID_SIZE], const char secret[SECRET_SIZE])
{
	// Generate hexadecimal representations of uuid and secret.
	char uuid_hex[UUID_LENGTH + 1], secret_hex[SECRET_SIZE * 2 + 1];
	*format_hex(secret_hex, secret, SECRET_SIZE) = 0;
	*format_hex(uuid_hex, uuid, UUID_SIZE) = 0;

	bool success = false;
	void *restrict db = db_init();
    if (!db) return false;

	do
	{
		struct string *query = db_sql_alloc("select client_id from devices where uuid='%s' and secret=0x%s", uuid_hex, secret_hex);
		if (!query) break;
		success = !mysql_real_query(db, query->data, query->length);
		free(query);
		if (!success) break;

		MYSQL_RES *result = mysql_store_result(db);
		if (!result) break;
		success = (mysql_num_rows(db) != 0);
		mysql_free_result(result);
	} while (false);

	db_term(db);
	return success;
}
